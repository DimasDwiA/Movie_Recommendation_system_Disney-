# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FKgR5ZBA-hIIFknF7pBBlm4cF7TvLO-3

# Import Libraries
"""

import pandas as pd
import numpy as np
import difflib
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""# Data Loading & Data understanding"""

df_movie = pd.read_csv('/kaggle/input/the-movies-dataset/movies_metadata.csv')
df_keyword = pd.read_csv('/kaggle/input/the-movies-dataset/keywords.csv')

"""## Data Movies

Pada Dataset Movie ini memiliki sekitar 45 ribu baris data (masih memiliki missing value dan duplicate data) dan 24 kolom :
- adult: Menunjukkan apakah film ditujukan untuk penonton dewasa atau tidak.
- belongs_to_collection: Berisi informasi tentang apakah film tersebut merupakan bagian dari sebuah koleksi atau waralaba (franchise).
- budget: Anggaran produksi film dalam bentuk angka, tetapi disimpan sebagai string.
- genres: Berisi informasi mengenai genre film dalam format JSON.
- homepage: URL dari situs web resmi film, jika ada.
- id: ID unik untuk setiap film di dataset.
- imdb_id: ID film yang terdaftar di situs IMDb, yang dapat digunakan untuk pencarian di platform tersebut.
- original_language: Bahasa asli dari film.
- original_title: Judul asli film dalam bahasa aslinya, sebelum diterjemahkan atau diubah untuk pasar internasional.
- overview: Sinopsis singkat atau ringkasan dari plot film.
- popularity: Ukuran popularitas film di berbagai platform.
- poster_path: Path ke poster film yang dapat digunakan untuk menampilkan gambar poster melalui situs TMDb.
- production_companies: Berisi nama perusahaan produksi film dalam format JSON.
- production_countries: Negara tempat film diproduksi, disimpan dalam format JSON.
- release_date: Tanggal rilis film. Biasanya dalam format YYYY-MM-DD.
- revenue: Pendapatan global yang dihasilkan oleh film, dalam dolar AS.
- runtime: Durasi film dalam menit.
- spoken_languages: Bahasa yang digunakan dalam film, disimpan dalam format JSON.
- status: Status produksi film.
- tagline: Slogan atau tagline dari film, yang sering kali digunakan dalam promosi.
- title: Judul resmi film yang mungkin berbeda dari judul aslinya (original_title).
- video: Menunjukkan apakah film tersebut memiliki trailer video (True atau False).
- vote_average: Skor rata-rata film berdasarkan penilaian dari pengguna.
- vote_count: Jumlah total suara atau penilaian yang diterima oleh film.
"""

df_movie.head()

df_movie.info()

# Mendeteksi Duplikat Data
df_movie.duplicated().sum()

# Memastikan data tidak ada yang missing value
df_movie.isnull().sum()

"""Seperti yang kita lihat bahwa hampir seluruh kolom memiliki missing value. Ada banyak cara dalam menangani missing value, namun pada kasus kali ini kita akan menghapus beberapa kolom karena tidak terlalu berpengaruh pada rekomendasi movie, untuk itu hanya kolom `original_title`, `genres`, `vote_average`, `overview` dan `Id` yang akan digunakan pada df_movie yang nantinya akan digabungkan dengan data keywords"""

df_movies = df_movie[['id', 'original_title', 'genres', 'overview', 'vote_average']]
# Membuat index pada dataset
df_movies['index'] = df_movies.index
df_movies.head()

print(f"the number of columns of the datasets: {df_movies.shape[1]}")
print(f"the number of rows of the datasets: {df_movies.shape[0]}")

# Menghapus baris di mana id tidak ada atau jika bukan angka
df_movies = df_movies[df_movies['id'].str.isnumeric()]

print(f"the number of columns of the datasets: {df_movies.shape[1]}")
print(f"the number of rows of the datasets: {df_movies.shape[0]}")

"""## Data Keywords

Pada Dataset Movie ini memiliki sekitar 46 ribu baris data (masih memiliki missing value dan duplicate data) dan 2 kolom :
- id: ID unik untuk setiap film, yang sesuai dengan kolom id di dataset movie. Ini adalah kunci yang dapat digunakan untuk menghubungkan kedua dataset.
- keywords: Berisi kata kunci atau tag yang relevan dengan film, dalam format JSON. Kata kunci ini menggambarkan tema atau elemen utama dalam film.
"""

df_keyword.head()

df_keyword.info()

print(f"the number of columns of the datasets: {df_keyword.shape[1]}")
print(f"the number of rows of the datasets: {df_keyword.shape[0]}")

# Mendeteksi Duplikat Data
df_keyword.duplicated().sum()

# Hapus duplikasi data
df_keyword = df_keyword.drop_duplicates()
# Cek duplikat data setelah duplikat dihapus
df_keyword.duplicated().sum()

print(f"the number of columns of the datasets: {df_keyword.shape[1]}")
print(f"the number of rows of the datasets: {df_keyword.shape[0]}")

# Memastikan data tidak ada yang missing value
df_keyword.isnull().sum()

"""# Data Preprocessing

## Data Merge

Pada tahapan ini kita melakukan merge data movies dengan data keywords
"""

df_movies['id'] = df_movies['id'].astype(int) # Ubah tipe data ke int karna sebelumnya adalah object
df_movies_all = pd.merge(df_movies, df_keyword, on='id', how='left')
df_movies_all.reset_index(inplace=True, drop=True)
df_movies_all.head()

"""Setelah dilakukan merge data movie dan data keyword berikut adalah informasi dari `data_movies_all` yang nantinya data ini akan digunakan untuk dilakukan pemodelan:
- id: ID unik untuk setiap film di dataset.
- original_title: Judul asli film dalam bahasa aslinya, sebelum diterjemahkan atau diubah untuk pasar internasional.
- genres: Berisi informasi mengenai genre film dalam format JSON.
- vote_average: Skor rata-rata film berdasarkan penilaian dari pengguna.
- overview: Sinopsis singkat atau ringkasan dari plot film.
- keywords: Berisi kata kunci atau tag yang relevan dengan film, dalam format JSON. Kata kunci ini menggambarkan tema atau elemen utama dalam film.

"""

print(f"the number of columns of the datasets: {df_movies_all.shape[1]}")
print(f"the number of rows of the datasets: {df_movies_all.shape[0]}")

"""Dikarenakan data `df_movies_all` ini hasil dari penggabungan dari kedua dataset untuk itu dilakukan pemeriksaan apakah data memiliki missing value atau duplikasi pada data, jika terdapat missing value atau duplikasi data kita hapus agar akurasi model saat merekomendasikan film bagus dan sesuai dengan preferensi model"""

# Memastikan data tidak duplikat
df_movies_all.duplicated().sum()

# Hapus Duplikasi data
df_movies_all = df_movies_all.drop_duplicates()
# Cek duplikat data setelah duplikat dihapus
df_movies_all.duplicated().sum()

# Memastikan data tidak ada yang missing value
df_movies_all.isnull().sum()

# Hapus missing value pada data
df_movies_all = df_movies_all.dropna()
# Cek missing value setelah dihapus
df_movies_all.isnull().sum()

print(f"the number of columns of the datasets: {df_movies_all.shape[1]}")
print(f"the number of rows of the datasets: {df_movies_all.shape[0]}")

"""Seperti yang dilihat diawal pada `df_movies_all.head()` isi dari kolom `genres` dan `keywords` itu memiliki banyak value (valuenya masih berformat JSON) untuk itu kita harus membersihkan dan mangambil nilai yang ingin yang kita pakai"""

# Ubah kolom genres yang hanya menampilkan genre saja tanpa id
df_movies_all['genres'] = df_movies_all['genres'].apply(lambda x: [i['name'] for i in eval(x)])
df_movies_all.head()

# Menghapus list pada kolom genre
df_movies_all['genres'] = df_movies_all['genres'].apply(lambda x: ' '.join(x))
df_movies_all.head()

# Melakukan hal yang sama pada kolom keywords
df_movies_all['keywords'] = df_movies_all['keywords'].apply(lambda x: [i['name'] for i in eval(x)])
df_movies_all['keywords'] = df_movies_all['keywords'].apply(lambda x: ' '.join([i.replace(" ", "") for i in x]))
# Hapus kolom id
df_movies_all.drop(['id'], axis=1, inplace=True)
df_movies_all.head()

"""Membuat kolom baru bernama `tags` dengan melakukan kombinasi dari kolom `original_title`, `genres` dan `keywords` untuk dikenversikan ke bentuk vectors menggunakan TF-IDF"""

#combine all selected features
df_movies_all['tags'] = df_movies_all["original_title"]+" "+df_movies_all["genres"]+" "+df_movies_all["keywords"]
df_movies_all.drop(['keywords'], axis=1, inplace=True)
df_movies_all = df_movies_all[['index', 'original_title', 'genres', 'vote_average', 'tags']]
df_movies_all.head()

"""# Modeling

Untuk model kali ini kita akan menggunakan Content Based Filtering dimana tujuan dari dibuatnya model ini adalah mencari kesamaan antara film dengan menggunakan cosine similarity, sehingga menampilkan preferensi sesuai dengan yang user cari atau ketertarikan user menyukai movie tersebut.

Sebelum kita membuat model kita harus ubah kolom `tags` ke bentuk vectors menggunakan teknik TF-IDF, Metode ini mengubah informasi tekstual menjadi nilai numerik, yang kemudian dapat digunakan untuk menghitung kemiripan (menggunakan cosine similarity) antar film.
"""

# Konversi data text ke vectors
vectorizer = TfidfVectorizer()
feature_vektor = vectorizer.fit_transform(df_movies_all['tags'])

# Lalu hitung cosine similarity dari hasil vectors dari matrix TF-IDF
similarity = cosine_similarity(feature_vektor)

"""melakukan pemeriksaan ukuran dari fitur yang telah divektorkan dan melakukan pemeriksaan ukuran dari hasil hitung cosine similarity"""

# Cek ukuran dari feature_vektor
print(feature_vektor.shape)

# Cek ukuran dari df_movies_all['original_title']
print(similarity.shape)

"""Buat dataframe untuk melihat kemungkinan kemiripan antar film dari hasil perhitungan cosine similarity"""

# Membuat dataframe untuk melihat hasil dari cosine similarity
df_similarity = pd.DataFrame(similarity, columns=df_movies_all['original_title'],
             index=df_movies_all['original_title']).sample(10, axis=1).sample(10, axis=0)
df_similarity

"""Setelah itu buat fungsi untuk menampilkan rekomendasi dari preferensi user, dengan proses sistem rekomendasi sebagai berikut:
1. Pengguna mencari atau memasukkan judul film.
2. Sistem menggunakan metode `difflib.get_close_matches` untuk menemukan judul yang paling dekat dengan set data.
3. Setelah film yang benar diidentifikasi, sistem menghitung kemiripan antara film yang dipilih dan semua film lainnya menggunakan matriks cosine similarity.
4. Sistem mengembalikan daftar film teratas yang paling mirip dengan film yang dipilih berdasarkan skor cosine similarity.
"""

def recommend_movie(movie_name, df_movies_all, similarity_matrix, k=15):
    """
    Merekomendasikan film berdasarkan kemiripan judul dengan dataset yang ada.

    Parameters:
    - movie_name (str): Nama film yang diinput oleh pengguna
    - df_movies_all (DataFrame): Dataset yang berisi informasi film, termasuk kolom 'original_title', 'genre', dan 'vote_average'
    - similarity_matrix (array): Matriks kemiripan antar film
    - k (int): Jumlah rekomendasi yang diinginkan (default: 10)

    Returns:
    - DataFrame: Rekomendasi film dalam bentuk DataFrame
    """
    # Mengambil daftar semua judul film dari dataset
    list_of_all_titles = df_movies_all["original_title"].tolist()

    # Mencari judul yang paling mirip dengan input pengguna
    find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles)

    if find_close_match:
        # Jika ditemukan film yang mirip, gunakan yang pertama dalam daftar
        close_match = find_close_match[0]

        # Mendapatkan indeks dari film yang cocok
        matched_movie = df_movies_all[df_movies_all['original_title'] == close_match]

        if not matched_movie.empty:  # Cek apakah film ditemukan
            index_of_the_movie = matched_movie["index"].values[0]

            # Mendapatkan skor kemiripan dengan film lainnya berdasarkan similarity_matrix
            similarity_scores = list(enumerate(similarity_matrix[index_of_the_movie]))

            # Mengurutkan film berdasarkan skor kemiripan secara menurun
            sorted_similarity_movie = sorted(similarity_scores, key=lambda x: x[1], reverse=True)

            # Menyiapkan list untuk menyimpan rekomendasi film
            recommendations = []

            # Menampilkan hingga k film yang paling mirip, kecuali film itu sendiri (indeks 0)
            for movie in sorted_similarity_movie[1:k+1]:  # Mulai dari indeks 1, lewati film itu sendiri
                index = movie[0]

                # Ambil judul, genre, dan vote_average
                title = df_movies_all.iloc[index]['original_title']
                genre = df_movies_all.iloc[index]['genres']
                vote_average = df_movies_all.iloc[index]['vote_average']

                # Tambahkan ke list rekomendasi
                recommendations.append({
                    'Title': title,
                    'Genre': genre,
                    'Vote Average': vote_average
                })

            # Mengembalikan rekomendasi dalam bentuk DataFrame
            return pd.DataFrame(recommendations)
        else:
            print(f"Sorry, the movie '{close_match}' was not found in the dataset.")
            return None
    else:
        print(f"Sorry, no close match found for '{movie_name}'.")
        return None

"""Selanjutnya kita dapat mencoba menggunakan fungsi tersebut untuk menampilkan film yang direkomendasikan sesuai dengan pencarian atau ketertarikan user terhadap film"""

movie_name = input("Movie apa yang ingin kamu tonton: ")

# Memanggil fungsi untuk merekomendasikan film
recommendation_movie = recommend_movie(movie_name, df_movies_all, similarity)
recommendation_movie

"""# Evaluasi

Dari model yang telah dibuat kita akan evaluasi apakah hasilnya cukup bagus atau tidak, dimana kita menggunakan precision sebagai evaluasi model yang kita telah buat
"""

k = 15
threshold = 5
movie_ratings = recommendation_movie['Vote Average'].values
movie_relevances = movie_ratings > threshold
precision = len(movie_ratings[movie_relevances]) / k
print(f'The precision of the recommendation system is {precision:.1%}')

"""Dengan hasil precision 73,3%, model ini sudah menjawab problem statement dengan cukup baik. Precision mengukur seberapa akurat rekomendasi yang diberikan model, yakni proporsi film yang direkomendasikan dan disukai pengguna dari semua yang disarankan. Nilai 73,3% menunjukkan bahwa sekitar 3 dari 4 film yang direkomendasikan sesuai dengan preferensi pengguna. Artinya, model berhasil memberikan rekomendasi yang relevan dan berkualitas, menjawab kebutuhan untuk memberikan saran yang personal."""